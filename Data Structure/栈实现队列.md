# 基于双栈实现队列的完整设计与实现深度解析

在上一篇文章中，我们探讨了如何利用队列的FIFO特性来模拟栈的LIFO行为（[[点击回顾：栈与队列的“跨界”对话：如何用双队列完美模拟栈的LIFO特性？](https://blog.csdn.net/2501_93679849/article/details/155791090?spm=1001.2014.3001.5501)]）。这是一个关于“数据顺序反转”的巧妙设计。现在，我们将面对一个对称且同样经典的问题：**如何用栈（LIFO，后进先出）来模拟队列（FIFO，先进先出）**。这更是深入理解栈与队列本质、锻炼算法设计思维的绝佳案例。

本文将详细介绍“双栈法”的原理、实现，并分析其优异的均摊时间复杂度。同时，我们也会将它与上一篇的“双队列法”进行深入对比，共同揭示数据结构抽象与互模拟的精妙之处。

# 一、设计哲学与架构

## 1.1 双栈模型的核心思想：LIFO到FIFO的转换

传统的队列操作——`Push`（入队）和`Pop`（出队）——要求元素从一端进入，从另一端离开。栈的天然特性使得元素只能从同一端（栈顶）进出。要用栈模拟队列，核心挑战在于如何将栈中天然倒置的元素顺序（LIFO）转化为队列需要的正序（FIFO）。

**双栈模型**（Two-Stack Model）巧妙地解决了这个问题，它将队列的职责拆分给两个独立的栈：

1. **输入栈（`s1`，Push Stack）：** 专门负责**入队操作（Push）**。所有新元素都无条件地推入这个栈。它就像一个高效的**“原料仓库”**。
2. **输出栈（`s2`，Pop Stack）：** 专门负责**出队操作（Pop/Peek）**。它维护了队列的正确顺序，只在需要提供队头元素时才被使用。它就像一个面向客户的**“售货柜台”**。

## 1.2 数据流向的比喻与职责分离

我们可以将这个模型想象成一个**餐厅的点菜与上菜系统**：

- **输入栈 (s1) 是“厨房”：** 顾客（入队操作）的所有订单（数据）都依次堆叠在厨房的工作台上。最晚下的订单在最上面（LIFO）。
- **输出栈 (s2) 是“出菜口”：** 当服务员需要给顾客上菜时（出队/查看队头），会从出菜口取。
- **转移操作是“配菜”：** 当出菜口空了，厨房会将所有订单（s1中的所有元素）**一次性**倒扣（Pop并Push）到出菜口的托盘上。由于栈操作的天然反转特性，原本厨房工作台最底下的（最早的订单，FIFO的队头）现在变成了出菜口托盘的最上面（s2的栈顶），等待被取出。

**职责分离**的精髓在于：`s1`永远只做入队，保持$O(1)$的效率；而`s2`永远只做出队/查看队头，仅在空时才进行昂贵的转移操作。

## 1.3 操作序列模拟

为了加深理解，我们模拟一个操作序列：`push(1), push(2), peek(), pop(), push(3), pop()`。

| **操作**         | **stackIn 状态 (栈底 → 栈顶)** | **stackOut 状态 (栈底 → 栈顶)** | **transfer() 动作**                 | **结果**                                           |
| ---------------- | ------------------------------ | ------------------------------- | ----------------------------------- | -------------------------------------------------- |
| $\text{push}(1)$ | $[1]$                          | $[]$                            | 否                                  | -                                                  |
| $\text{push}(2)$ | $[1, 2]$                       | $[]$                            | 否                                  | -                                                  |
| $\text{peek}()$  | $[1, 2]$                       | $[]$                            | **是**：$[1, 2] \rightarrow [2, 1]$ | $\text{stackOut}$ 变为 $[1, 2]$ (栈顶为 1)。返回 1 |
| $\text{pop}()$   | $[]$                           | $[2, 1]$                        | 否                                  | 移除并返回 1                                       |
| $\text{push}(3)$ | $[3]$                          | $[2]$                           | 否                                  | -                                                  |
| $\text{pop}()$   | $[3]$                          | $[2]$                           | 否                                  | 移除并返回 2                                       |

**关键点**：`stackOut` 只有在为空时才会被重新填充。在 $\text{pop}()$ 2 之后，队列的队头（如果还有）将位于 $\text{stackIn}$ 的 $[3]$ 之后。

## 1.4 时间复杂度摊还分析的理论基础

双栈实现队列的性能优势，并不在于所有操作都能达到$O(1)$的最优时间复杂度，而在于其\*\*摊还时间复杂度（Amortized Time Complexity）\*\*为$O(1)$。

- **最坏情况（Worst Case）：** 发生在`s2`为空，且`s1`中存有$N$个元素时。此时需要执行$N$次Pop和$N$次Push，将所有元素转移到`s2`，总时间复杂度为$O(N)$。
- **最佳情况（Best Case）：** `s2`非空时，直接进行Pop或Peek，时间复杂度为$O(1)$。
- **摊还分析：** 考虑一个包含$N$次操作的序列。虽然某次操作可能是$O(N)$（转移数据），但接下来的$N-1$次操作都将是$O(1)$（直接从`s2`取）。在$N$次操作的总成本中，$O(N)$的转移成本只发生了一次。因此，**平均到每次操作的成本为 $O(N)/N = O(1)$**。这种将高成本分摊到多次低成本操作上的分析方法，正是双栈队列高效的关键。

# 二、核心函数深度解析

## 2.1 `myQueuePush`函数详解

**函数功能：** 实现队列的入队操作（Enqueue）。


```c
// [O(1)] 队列入队操作：将元素x压入输入栈s1
void myQueuePush(MyQueue* obj, int x) 
{
	assert(obj);
	// 算法步骤：
	// 1. 断言检查指针有效性。
	// 2. 将新元素x直接压入输入栈s1。
	STPush(&(obj->s1),x); // O(1)
}
```

## 为什么只需简单压入`s1`？

`myQueuePush`的操作极为简洁，它不需要检查`s2`的状态，也不需要执行任何转移操作。这体现了**职责分离**的设计原则：`s1`的唯一职责就是接收入队请求，并安全地存储数据。

从队列的**FIFO**特性来看，新入队的元素$x$必须排在所有现有元素之后。栈`s1`是LIFO，将$x$压入栈顶，它自然位于当前所有元素之“上”。当未来需要进行 Pop 操作时，所有元素会被转移到`s2`，此时$x$将位于`s2`的栈底，从而保证了其是**最晚出队的元素**，完美满足FIFO要求。

### 时间复杂度：$O(1)$的保证

假设底层栈的`STPush`操作（包括动态扩容的摊还成本）是$O(1)$的，那么`myQueuePush`函数中只包含一个`STPush`调用，其时间复杂度为严格的**$O(1)$**。这是该模型性能稳定的基石之一。

### 空间复杂度分析

`myQueuePush`操作本身不涉及额外的辅助空间分配，其空间开销仅是存储新元素$x$所需的一个`STDataType`大小的空间，以及栈底层可能触发的动态扩容操作。整个队列结构的**空间复杂度**取决于存储的元素总数$N$，为**$O(N)$**。

### 与普通队列`push`的对比

| **特性**       | **双栈队列 (myQueuePush)** | **数组队列 (如循环队列)** | **链表队列**                 |
| -------------- | -------------------------- | ------------------------- | ---------------------------- |
| **操作步骤**   | 只需一次`STPush`到`s1`。   | 需要计算尾指针并存储。    | 需要创建新节点并调整尾指针。 |
| **时间复杂度** | 严格$O(1)$。               | 严格$O(1)$。              | 严格$O(1)$。                 |
| **内存开销**   | 两个栈的动态数组存储。     | 一个固定大小的数组存储。  | 每个元素需额外存储指针。     |

## 2.2 `myQueuePeek`函数详解

**函数功能：** 获取队头元素（Front），但不移除。

```c
// [摊还O(1)，最坏O(N)] 队列查看队头元素操作
int myQueuePeek(MyQueue* obj)
{
	assert(obj);
	// 1. 检查输出栈s2是否为空。
	if (STEmpty(&(obj->s2)))
	{
		// 2. 关键的“懒惰转移”策略：当s2为空时，才执行数据转移。
		// 转移操作确保了FIFO的顺序：s1的栈底（最早入队）将成为s2的栈顶。
		while (!STEmpty(&(obj->s1)))
		{
			// a. 取出s1栈顶元素
			STDataType data = STTop(&(obj->s1)); // O(1)
			STPop(&(obj->s1)); // O(1)
			
			// b. 压入s2
			STPush(&(obj->s2), data); // O(1)
		}
	}
	// 3. 返回s2的栈顶元素，即当前队头。
	return STTop(&(obj->s2)); // O(1)
}
```

**注意**：在提供的代码中，转移数据的`while`循环也可以使用的是`int x = STSize(&(obj->s1)); while (x--)`，虽然写法不同，但**逻辑功能是等价的**，都是将`s1`中的所有元素依次弹出并压入`s2`。

### 懒惰转移策略的设计哲学

`myQueuePeek`（以及`myQueuePop`）的核心是**“懒惰转移”（Lazy Transfer）**策略。

- **懒惰**：数据转移操作不是在`Push`时立即执行，也不是在每次`Peek`或`Pop`时都执行。它只在**不得不执行**的时候才触发，即**当输出栈`s2`为空**时。
- **转移**：一旦触发，**必须将`s1`中的所有元素一次性全部转移到`s2`**。

这个策略的优势在于：它避免了不必要的重复转移。只要`s2`非空，所有的Peek/Pop操作都能以$O(1)$的速度进行，直到`s2`被耗尽。

### `while`循环的精确执行次数分析

假设在触发转移时，`s1`中恰好有$N$个元素。

1. **循环条件：** `!STEmpty(&(obj->s1))` 或 `x--` 循环$N$次。
2. **单次循环内部：** 包含一次`STTop`、一次`STPop`（从`s1`）和一次`STPush`（到`s2`），都是$O(1)$操作。
3. **总成本：** 转移操作的总时间复杂度为 $N \times O(1) = O(N)$。

转移完成后，`s1`变空，`s2`中也正好有$N$个元素，且顺序完全反转，队头元素位于`s2`的栈顶。

### 摊还时间复杂度计算过程

我们考虑一个包含$N$次`Push`和`Peek/Pop`混合操作的序列。

- **总Push成本：** $N_{push} \times O(1)$
- **总Pop/Peek成本：**
  - **$s2$非空时：** $O(1)$。
  - **$s2$为空时（触发转移）：** $O(N_{s1})$。

在一个完整的生命周期中（从队列为空开始，到再次为空），假设总共Push了$K$个元素。这$K$个元素**只会从`s1`转移到`s2`一次**。

- **转移总成本：** $\sum (\text{转移操作})=\sum (K \times O(1)) \text{ 约等于 } O(K)$。
- **Pop/Peek总次数：** $\text{Pop/Peek 总次数} \text{ 约等于 } K$ 次。
- **总操作次数：** $\text{总操作次数} \text{ 约等于 } 2K$ 次（$K$次Push, $K$次Pop）。

**摊还成本** $\approx \frac{\text{Push成本} + \text{转移成本} + \text{Pop成本}}{\text{总操作次数}} \approx \frac{O(K) + O(K) + O(K)}{2K} = O(1)$。

### 为什么这是性能优化的关键？

“懒惰转移”是性能优化的关键，因为它确保了**每个元素只会被移动两次**：一次是Push到`s1`，另一次是从`s1`转移到`s2`。尽管转移操作在最坏情况下耗时$O(N)$，但其成本被平摊到了$N$次$O(1)$的Pop/Peek操作上。这种**平滑（amortize）**了峰值延迟的特性，使得双栈队列在实际应用中表现出和原生队列一样高效的平均性能。

## 2.3 `myQueuePop`函数详解

**函数功能：** 移除并返回队头元素（Dequeue）。


```c
// [摊还O(1)，最坏O(N)] 队列出队操作
int myQueuePop(MyQueue* obj) 
{
	assert(obj);
	// 1. 复用myQueuePeek获取队头元素。
	//    此操作会确保s2非空，并在s2为空时触发数据转移。
	int ret = myQueuePeek(obj); // 摊还 O(1) 或 最坏 O(N)

	// 2. 将s2的栈顶元素弹出，完成移除操作。
	STPop(&(obj->s2)); // O(1)
	
	// 3. 返回被移除的元素。
	return ret;
}
```

### 复用`myQueuePeek`的巧妙设计

`myQueuePop`的实现极其优雅，它完全**复用**了`myQueuePeek`的核心逻辑，避免了代码冗余和逻辑重复。

1. **调用`myQueuePeek(obj)`：** 这一步解决了两个关键问题：
   - **数据可用性：** 如果`s2`为空，它会执行`s1`到`s2`的完整转移，保证队头元素已经位于`s2`的栈顶。
   - **返回值：** 它返回了正确顺序的队头元素。
2. **调用`STPop(&(obj->s2))`：** 在确定队头元素已经安全位于`s2`的栈顶后，只需执行一次$O(1)$的`STPop`，即可将该元素从队列中移除。

### 边界条件处理（空队列的`assert`）

代码在`myQueuePeek`的内部通过`assert(!STEmpty(&(obj->s2)))`来检查转移完成后`s2`是否仍然为空，从而间接检查了整个队列是否为空。而在`myQueuePop`函数开头，虽然没有显式的空检查，但由于`myQueuePeek`内部的断言（或在`STPop`的断言中），如果尝试对一个空队列进行 Pop，程序将**断言失败（Assert Crash）**，起到了边界条件保护的作用。

### 与`peek`函数的协同工作模式

`Pop`和`Peek`通过共享`s2`的状态和懒惰转移机制，形成了一个高效的协同工作模式：

| **函数** | **目标** | **核心逻辑**                      | **转移触发**             |
| -------- | -------- | --------------------------------- | ------------------------ |
| `Peek`   | 查看队头 | 确保队头在`s2`栈顶。              | **是**，若`s2`为空。     |
| `Pop`    | 移除队头 | 调用`Peek`定位，然后`STPop`移除。 | **是**，通过`Peek`触发。 |

无论调用`Peek`还是`Pop`，只要`s2`为空，都将引发一次完整的转移。这保证了在需要队头元素时，数据总是处于正确的位置。

## 2.4 `myQueueEmpty`函数详解

**函数功能：** 判断队列是否为空。

```c
// [O(1)] 队列判空操作
bool myQueueEmpty(MyQueue* obj)
{
	// 算法步骤：
	// 1. 当且仅当输入栈s1和输出栈s2同时为空时，队列才为空。
	return (STEmpty(&(obj->s1)) && STEmpty(&(obj->s2))); // O(1)
}
```

### 双栈同时为空的判断逻辑

队列中的所有元素要么在**输入栈`s1`中（待处理），要么在输出栈`s2`中（待取出）。因此，一个队列为空的充要条件**是两个存储位置都必须是空的。

- **情况一：** `s1`为空，`s2`非空。队列非空，元素在`s2`中等待出队。
- **情况二：** `s1`非空，`s2`为空。队列非空，元素在`s1`中等待转移。
- **情况三：** `s1`非空，`s2`非空。队列非空，元素分散在两个栈中。

只有当两个栈都返回`true`时（`s1`空 **且** `s2`空），`myQueueEmpty`才返回`true`，判断逻辑是精确且完备的。

### 时间复杂度分析

`myQueueEmpty`函数只包含两个$O(1)$的`STEmpty`调用和一个逻辑与操作，因此其时间复杂度为严格的\*\*$O(1)$\*\*。它不依赖于队列的大小$N$，是一个非常高效的操作。

### 与`size`函数的内在联系

如果实现了一个`myQueueSize`函数（代码中已提供），它将返回 `STSize(&(obj->s1)) + STSize(&(obj->s2))`。那么`myQueueEmpty`实际上等价于 `myQueueSize(obj) == 0`。两者都依赖于对两个底层栈状态的查询。


# 三、内存管理与辅助函数

内存管理是C语言编程中不可或缺的一环，对于动态数据结构尤为重要。

## 3.1 `myQueueCreate`的初始化策略

**功能：** 为`MyQueue`结构体分配内存并初始化其内部的两个栈。


```c
MyQueue* myQueueCreate() 
{
	MyQueue* obj = (MyQueue*)malloc(sizeof(MyQueue)); // 1. 分配MyQueue结构体空间
	if (obj == NULL)
	{
		perror("malloc");
		exit(-1);
	}
	STInit(&(obj->s1)); // 2. 初始化s1 (Input Stack)
	STInit(&(obj->s2)); // 3. 初始化s2 (Output Stack)
	return obj; // 4. 返回指针
}
// 复杂度：O(1)
```

1. **对象分配：** 使用`malloc`为上层的`MyQueue`结构体分配内存。
2. **底层初始化：** 随后，必须调用栈的初始化函数`STInit`来初始化`s1`和`s2`。`STInit`负责将栈的**内部状态**（如`a`指针设为`NULL`，`capacity`和`top`设为0）置为安全初始状态。

这种**自底向上**的初始化策略（先初始化内嵌结构，再返回外部结构）保证了新创建的队列对象是一个完全可用的、空队列。

## 3.2 `myQueueFree`的销毁顺序重要性

**功能：** 释放`MyQueue`占用的所有动态内存。


```c
void myQueueFree(MyQueue* obj) 
{
	STDestroy(&(obj->s1)); // 1. 销毁s1占用的动态数组空间
	STDestroy(&(obj->s2)); // 2. 销毁s2占用的动态数组空间
	free(obj); // 3. 释放MyQueue结构体本身的堆空间
}
// 复杂度：O(1) (忽略底层栈的内存释放成本)
```

**销毁顺序的重要性：**

1. **先销毁内部：** 必须先调用`STDestroy`来释放`s1`和`s2`内部指向的**动态数组**内存（`free(pst->a)`），这是存储实际数据的地方。
2. **后释放外部：** 最后，才能`free(obj)`来释放`MyQueue`结构体本身在堆上占用的内存。

如果顺序颠倒，先释放了`obj`，那么将无法通过`obj->s1`和`obj->s2`访问到两个栈，导致栈内部的动态数组内存泄漏。这种**自上而下**的释放顺序保证了资源释放的完整性。


# 四、算法全面分析

## 4.1 与《用队列实现栈》的深度对比

通过实现“用栈实现队列”和前一篇的“用队列实现栈”，我们完成了数据结构互模拟系列中的两个经典问题。

| **对比维度**   | **用两个队列实现栈**                                 | **用两个栈实现队列**                                         |
| -------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| **模拟目标**   | FIFO $\rightarrow$ LIFO                              | LIFO $\rightarrow$ FIFO                                      |
| **核心结构**   | 两个队列 (`q1`, `q2`)                                | 两个栈 (`stackIn`, `stackOut`)                               |
| **关键策略**   | `pop`时，将 $n-1$ 个元素转移到辅助队列，留最后一个。 | `pop`/`peek`时，若`stackOut`空，则**一次性反转搬运**`stackIn`所有元素。 |
| **时间复杂度** | $\text{push } O(1), \text{pop } O(n)$（或反之）      | $\text{push } O(1), \text{pop/peek } \mathbf{均摊\ } O(1)$   |
| **思想核心**   | **元素筛选/单次转移**（暴露最后进入的元素）          | **顺序反转/懒惰加载**（将 LIFO 转化为 FIFO）                 |

### 设计启示：适配器模式与抽象

这两道题目都体现了计算机科学中的**适配器设计模式（Adapter Pattern）**思想。我们没有直接修改栈或队列的底层实现，而是将一个或多个既有组件（栈）封装起来，对外提供一个全新的接口（队列）。

- **用队列实现栈**：是利用 $O(N)$ 复杂度的代价，实现了对队列结构的**“瞬间重排”**，以暴露栈顶元素。
- **用栈实现队列**：则是利用 $O(1)$ 的均摊复杂度，巧妙地实现了**“流式顺序反转”**。

通过以上对比，我们可以发现，这两道题就像一对“镜像问题”，共同揭示了数据结构抽象的强大魅力。它们都要求我们**绕过数据结构的直接行为，通过对其基本操作的组合与调度，来构建新的语义**。这种对抽象能力的锻炼，对于未来理解和应用更复杂的设计模式至关重要。

## 4.2 时间复杂度的三种场景分析

| **函数**                 | **最佳情况（s2非空）** | **最坏情况（需要转移）**                 | **摊还情况（连续操作序列）** |
| ------------------------ | ---------------------- | ---------------------------------------- | ---------------------------- |
| **`myQueuePush`**        | $O(1)$                 | $O(1)$                                   | $O(1)$                       |
| **`myQueuePeek`**        | $O(1)$                 | $O(N)$ (当$s2$为空，且$s1$有$N$个元素时) | **$O(1)$**                   |
| **`myQueuePop`**         | $O(1)$                 | $O(N)$ (同`Peek`)                        | **$O(1)$**                   |
| **`myQueueEmpty`**       | $O(1)$                 | $O(1)$                                   | $O(1)$                       |
| **`myQueueCreate/Free`** | $O(1)$                 | $O(1)$                                   | $O(1)$                       |

**摊还分析的数学之美：** 正如第二部分所述，双栈队列的精妙之处在于将$O(N)$的高峰成本**摊还**成了$O(1)$的平均成本。这是一种非常重要的算法设计思想，它允许我们在局部牺牲效率，以换取全局的效率保证。

## 4.3 空间复杂度分析

### 额外空间开销

- **数据存储空间：** 队列中所有$N$个元素分别存储在`s1`和`s2`的动态数组中。由于`s1`和`s2`的总容量会根据元素数量$N$进行动态调整，因此存储$N$个元素的总空间复杂度为**$O(N)$**。
- **结构体开销：** 外部的`MyQueue`结构体只包含两个`ST`结构体，它们存储了指针、容量和栈顶索引等少数元数据，这部分开销是**$O(1)$**。
- **总空间复杂度：** $O(N) + O(1) = O(N)$。

### 与链表实现的对比

| **特性**     | **双栈队列（基于数组栈）**                                   | **链表队列**                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------ |
| **Push**     | $O(1)$                                                       | $O(1)$                                           |
| **Pop**      | 摊还$O(1)$                                                   | $O(1)$                                           |
| **空间效率** | 数组存储紧凑，无额外指针开销，空间效率高。                   | 每个节点需额外存储一个或两个指针，空间开销略大。 |
| **局部性**   | 数组存储，数据访问具有更好的**缓存局部性**（Cache Locality）。 | 链表节点分散在内存中，缓存局部性较差。           |

因此，基于双栈和动态数组实现的队列，在**空间效率**和**缓存性能**方面通常优于传统的链表实现。

# 五、应用场景与扩展思考

## 5.1 实际应用场景

队列作为基础数据结构，其FIFO特性决定了它在需要保持顺序的场景中不可替代。双栈实现提供了一种灵活的替代方案：

1. **任务调度系统：** 在批处理或多线程环境中，任务常常被放入队列等待执行。双栈实现可以灵活处理任务的快速入队（Push to $s1$）和顺序出队（Pop from $s2$）。
2. **数据流处理（Streaming Data）：** 处理网络数据包、日志记录等连续数据流时，需要保持数据的原有顺序。双栈结构能够以$O(1)$的平均效率保证数据处理的顺序性。
3. **广度优先搜索（BFS）：** BFS算法的核心是使用队列来存储待探索的节点。双栈队列可以作为底层的存储结构。
4. **浏览器历史记录（简化模型）：** 虽然实际实现更复杂，但双栈模型与“前进/后退”功能有异曲同工之妙，即利用两个栈来回转移数据。

## 5.2 扩展可能性

### 1. 如何实现线程安全版本？

在多线程环境中，多个线程可能同时调用`myQueuePush`和`myQueuePop`，这将导致竞争条件（Race Condition）。

- **解决方案：** 引入**互斥锁（Mutex）**。
  - 在`myQueuePush`中，在`STPush`前后加锁和解锁。
  - 在`myQueuePeek`和`myQueuePop`中，在执行**懒惰转移**操作的整个临界区（`if (STEmpty(&(obj->s2))) { ... 转移代码 ... }`）加锁。
  - 在返回队头（`STTop`）或移除队头（`STPop`）时也需保持锁，以确保操作的原子性。

### 2. 如何支持泛型？

C语言不支持原生泛型。但可以通过以下方式实现：

- **`void\*` 指针：** 将`STDataType`定义为`void*`，让栈存储数据的指针。用户在Push时需要将数据指针传递给队列，Pop时获取到指针，并自行进行类型转换和解引用。
- **宏或代码生成：** 为不同数据类型定义宏或使用脚本生成代码，这是C语言中实现泛型的一种常见方法。

### 3. 双向队列（Deque）的思考

**双向队列（Deque）**允许在两端进行Push和Pop。

- **挑战：** 仅用两个栈无法高效实现双向队列。
- **扩展方案：** 需要**四个栈**。
  - 两个栈实现前端队列（队头Pop/Peek）。
  - 两个栈实现后端队列（队尾Pop/Peek）。
  - 这会显著增加复杂性，通常会使用双向链表来实现Deque。


# 结论与展望

双栈实现队列是一种将LIFO结构巧妙地转化为FIFO结构的高级应用。它不仅是算法思想的体现，更是工程实践中对效率和空间的一种权衡。

通过**职责分离**的设计哲学和**懒惰转移**的优化策略，我们实现了：

1. 稳定的$O(1)$入队时间复杂度。
2. 优秀的$O(1)$**摊还**出队/查看队头时间复杂度。
3. $O(N)$的线性空间复杂度，且缓存局部性优良。

这种设计模式提醒我们，在面对数据结构转换问题时，不必拘泥于单一结构的直接操作，而可以通过组合和精妙的转移策略，实现功能上的完美模拟和性能上的高效保证。理解其背后的摊还分析原理，是掌握工业级算法设计的关键。

**附录：常见面试问题解析**

- **Q: 为什么`Push`时不能直接转移数据？**
  - **A:** 如果每次`Push`都将`s1`中的数据转移到`s2`再加新元素，`Push`操作将退化为$O(N)$，且每次`Push`都会打乱`s2`中的正确顺序，导致算法失败。
- **Q: 转移操作时为什么必须一次性转移`s1`的所有元素？**
  - **A:** 如果只转移一个元素，则下一次`Pop`时`s1`的队头仍然在`s1`的底部，无法取出，且转移操作会反复进行，效率极低。一次性转移保证了$s1$中最底部的元素（最早入队）被放到$s2$的顶部，等待连续$N$次的$O(1)$ Pop。
- **Q: 如果使用`realloc`而不是`malloc`，底层栈的实现会有什么变化？**
  - **A:** 如果使用`realloc`，`STPush`在扩容时会更高效且更安全：它能原地扩展内存或在新地址分配空间并自动拷贝数据，避免了手动拷贝数据的开销和潜在错误。这将使底层栈的`Push`操作（包括扩容）在**摊还意义上**更稳定地保持$O(1)$。

# 完整源码

```c
typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;

// 初始化和销毁
void STInit(ST* pst)
{
	assert(pst);
	pst->a = NULL;
	pst->capacity = pst->top = 0;
}
void STDestroy(ST* pst)
{
	assert(pst);
	free(pst->a);
	pst->a = NULL;
}
// 入栈  出栈
void STPush(ST* pst, STDataType x)
{
	assert(pst);
	if (pst->capacity == pst->top)
	{
		int newcapacity = pst->capacity == 0 ? 4 : 2 * pst->capacity;
		STDataType* tmp = (STDataType*)malloc(sizeof(STDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("malloc");
			exit(-1);
		}
		pst->a = tmp;
		pst->capacity = newcapacity;
	}
	pst->a[pst->top++] = x;
}
void STPop(ST* pst)
{
	assert(pst && pst->top > 0);
	pst->top--;
}

// 取栈顶数据
STDataType STTop(ST* pst)
{
	assert(pst && pst->top > 0);
	return pst->a[(pst->top) - 1];
}

// 判空
bool STEmpty(ST* pst)
{
	assert(pst);
	return pst->top == 0;
}
// 获取数据个数
int STSize(ST* pst)
{
	assert(pst);
	return pst->top;
}

typedef struct MyQueue 
{
	ST s1;//push
	ST s2;//pop
} MyQueue;


MyQueue* myQueueCreate() 
{
	MyQueue* obj = (MyQueue*)malloc(sizeof(MyQueue));
	if (obj == NULL)
	{
		perror("malloc");
		exit(-1);
	}
	STInit(&(obj->s1));
	STInit(&(obj->s2));
    return obj;
}

bool myQueueEmpty(MyQueue* obj)
{
	return (STEmpty(&(obj->s1)) && STEmpty(&(obj->s2)));
}

void myQueuePush(MyQueue* obj, int x) 
{
	assert(obj);
	STPush(&(obj->s1),x);
}

int myQueuePeek(MyQueue* obj)
{
	assert(obj);
	if (STEmpty(&(obj->s2)))
	{
		//倒数据
		int x = STSize(&(obj->s1));
		while (x--)
		{
			STPush(&(obj->s2), STTop(&(obj->s1)));
			STPop(&(obj->s1));
		}
	}
	return STTop(&(obj->s2));
}
int myQueuePop(MyQueue* obj) 
{
	assert(obj);
	int ret = myQueuePeek(obj);
	STPop(&(obj->s2));
	return ret;
}

void myQueueFree(MyQueue* obj) 
{
	STDestroy(&(obj->s1));
	STDestroy(&(obj->s2));
	free(obj);
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);

 * int param_2 = myQueuePop(obj);

 * int param_3 = myQueuePeek(obj);

 * bool param_4 = myQueueEmpty(obj);

 * myQueueFree(obj);
*/
```

